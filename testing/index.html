<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>devonfw ng2 training - testing</title>
    <link rel="icon" href="../common/img/favicon.ico">

    <link rel="stylesheet" href="../reveal.js-3.3.0/css/reveal.css">
    <link rel="stylesheet" href="../reveal.js-3.3.0/css/theme/black.css">
    <link rel="stylesheet" href="../common/css/common.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../reveal.js-3.3.0/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../reveal.js-3.3.0/css/print/pdf.css' : '../reveal.js-3.3.0/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<section class="devon-link">
    <a href="http://devonfw.github.io" target="_blank"><img height="50px" src="../common/img/devon_logo_white.png"></a>
</section>
<section class="angular-link">
    <a href="http://angular.io" target="_blank"><img height="50px" src="../common/img/angular.svg"></a>
</section>
<div class="devon reveal">
    <div class="slides">
        <section>
            <h1>Testing</h1>
			<img class="reset" src="img/angular-2-testing.jpg">
		</section>	
        <section>
			<h2>Tools</h2>
			<ul>
				<li><span class="highlight">Jasmine</span> - BDD testing framework</li>
				<li><span class="highlight">Angular Testing Utilities</span> - create test environment for Angular application code under test</li>
				<li><span class="highlight">Karma</span> - test runner</li>
				<li><span class="highlight">Protractor</span> - end-to-end testing framework built on top of Selenium Webdriver</li>
			</ul>
			<p><small><a target="_blank" href="https://angular.io/docs/ts/latest/guide/testing.html">https://angular.io/docs/ts/latest/guide/testing.html</a></small><p>		
		</section>
		<section>
			<h2>Jasmine syntax</h2>
			<pre><code class="hljs typescript">// test suite
describe('HelloService', () => {

  // spec
  it('should say hello', () => {
      let sut = new HelloService();

      let actual = sut.speak();

      expect(actual).toBe('hello'));
  });

});</code></pre>
            <p>This test ist read: <blockquote>HelloService should say hello</blockquote></p>
		</section>
		<section>
            <h3>Testing conventions</h3>
            <p>HelloService spec file is placed in the <span class="highlight">same folder</span>.</p>
            <ul>
                <li>hello.service.ts</li>
                <li>hello.service.spec.ts</li>
            </ul>
        </section>
        <section>
            <h3>Why is that?</h3>
            <ul>
                <li>Such tests are easy to <span class="highlight">find</span></li>
                <li>You see at a glance if a part of our application <span class="highlight">lacks tests</span>.</li>
                <li>Nearby tests can reveal <span class="highlight">how a part works</span> in context.</li>
                <li>When you move the source (inevitable), you <span class="highlight">remember to move the test</span>.</li>
                <li>When you rename the source file (inevitable), you <span class="highlight">remember to rename</span> the test file.</li>
            </ul>
            <div class="quote-source">
                <a href="https://angular.io/docs/ts/latest/guide/testing.html#!#faq" target="_blank">Angular Docs</a>
            </div>
            <p>
                Remember how the build differs to Java or .Net. No test code is build for production by <span class="highlight">file pattern</span>.
                <blockquote>*.spec.ts</blockquote>
            </p>
        </section>
        <section>
            <h3>Configuration</h3>
            <p>Karma is configured with <blockquote>karma.conf.js</blockquote></p>
            <p>Start karma with <blockquote>karma start</blockquote></p>
            <p>Angular-CLI abstracts from karma and lets you start with <blockquote>ng test</blockquote></p>
        </section>
        <section>
            <h3>Patterns</h3>
            <ul>
                <li>AAA / <span class="highlight">GWT</span> is always a good idea!</li>
                <li>When testing more than one function use <span class="highlight">nested describes</span>.</li>
                <li>Create const helper and variables outside of specs to keep <span class="highlight">specs short and readable</span>.</li>
                <li>Initialize inside <code class="typescript highlight">beforeEach()</code> function
                    <pre><code class="typescript">let sut: TestService;

describe('TestService', () => {
  beforeEach(() => {
    sut = new TestService;
  });
  ...
}</code></pre>
                </li>
            </ul>
        </section>
        <section>
            <h3>Expecting behavior</h3>
            <p>expect value is 1 <pre><code class="typescript">expect(value).toEqual(1);</code></pre></p>
            <p>negatin with not <pre><code class="typescript">expect(value).not.toEqual(1);</code></pre></p>
            <p>expect value greater <pre><code class="typescript">expect(value).toBeGreaterThan(0);</code></pre></p>
            <p>truthy / falsy<pre><code class="typescript">expect(value).toBeTruthy(); expect(value).toBeFalsy();</code></pre></p>
            <div class="quote-source">
                <a href="https://jasmine.github.io/2.0/introduction.html" target="_blank">see Jasmine Docs</a>
            </div>
        </section>
        <section>
            <h3>Mocking, Stubbing, Faking, Spies, etc.</h3>
            <p>Jasmine comes pre-equipped with mocking ability.</p>
            <p>Create a spy <pre><code class="typescript">spyOn(obj, 'methodName');</code></pre></p>
            <p>Assert method has been called <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalled()</code></pre></p>
            <p>Assert method has been called with argument <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalledWith(args)</code></pre></p>            
            <p>Assert method has been called amount of times <pre><code class="typescript">expect(obj.methodName).toHaveBeenCalledTimes(count);</code></pre></p>                        
        </section>
        <section>
            <section>
                <h3>Isolated Tests</h3>
                <p>Isolated unit tests examine an instance of a class all by itself <span class="highlight">without any dependence on Angular</span> or any injected values.</p>
                <div class="quote-source">
                    <a href="https://angular.io/docs/ts/latest/guide/testing.html#!#isolated-v-testing-utilities" target="_blank">Angular Docs</a>
                </div>
            </section>
            <section>
                <h3>When to use isolated tests?</h3>
                <ul>
                    <li>Services</li>
                    <li>Pipes</li>
                    <li>Components (if possible)</li>
                    <li>Directives (if possible)</li>
                </ul>
            </section>
            <section>
                <h3>HelloService Example</h3>
                <p>Given are three files.</p>
                <ul>
                   <li>hello.service.spec.ts</li> 
                   <li>hello.service.ts</li> 
                   <li>speaker.ts</li> 
                </ul>
            </section>
            <section>
                <h3>Speaker</h3>
                <pre><code class="max-height-unset typescript">export class Speaker {
    speak(val: string): void {
        console.log('speaker:', val); // highly sophisticated operation...
    }
}
</code></pre>
            </section>
            <section>
                <h3>HelloService</h3>
                <pre><code class="max-height-unset typescript">import { Injectable } from '@angular/core';

import { Speaker } from './speaker';

@Injectable()
export class HelloService {
    private speech: string[] = [];

    constructor(private speaker: Speaker) { }

    say(line: string): void {
        this.speaker.speak(line);
        this.speech.push(line);
    }

    getSpeech(): string {
        return this.speech.join('\n');
    }
}
</code></pre>
            </section>
            <section>
                <h3>HelloService spec</h3>
                <pre><code class="max-height-unset javascript">const speakerFake = {
  speak: (v: string) => {}
} as Speaker;
let sut: HelloService;

describe('HelloService', () => {
  beforeEach(() => {
    sut = new HelloService(speakerFake);
  });

  describe('say', () => {
    it('should call Speaker', () => {
      // Given
      const speechLine = 'This is Sparta!';
      spyOn(speakerFake, 'speak');

      // When
      sut.say(speechLine);

      // Then
      expect(speakerFake.speak).toHaveBeenCalledWith(speechLine);
    });
  });
});</code></pre>
            </section>
        </section>
        <section>
            <section>
                <h3>Angular testing utilities</h3>
                <p>Let you test components including their <span class="highlight">interaction with Angular</span>.</p>
            </section>
            <section>
                <h3>TestBed</h3>
                <p>TestBed creates an Angular module.</p>
                <p>Its purpose is to create a <span class="highlight">controlled test setup</span>.</p>
                <pre><code>beforeEach(() => {
  TestBed.configureTestingModule({
    declarations: [ HelloComponent ],
  });
  ...
});</code></pre>
                <p><code>TestBed.createComponent(HelloComponent)</code> exposes the API relevant for testing a component.</p>
            </section>
            <section>
                <h3>Testing API</h3>
                <p><code>ComponentFixture</code>: Fixture for <span class="highlight">debugging and testing</span> a component. Returned by <code>TestBed.createComponent(HelloComponent)</code></p>
                <p><code>ComponentFixture.componentInstance</code> provides <span class="highlight">access to the component</span></p>
                <p><code>ComponentFixture.debugElement</code> provides <span class="highlight">access to the components HTML tree</span></p>
                <p>... which <span class="highlight">can be queried</span> - e.g. by css selector <code>DebugElement.query(By.css('h1'))</code></p>
                <p>DebugElement.nativeElement provides <span class="highlight">access to <code>HTMLElement</code></span> (native browser API)</p>
            </section>
            <section>
                <h3>Example from Angular Docs</h3>
                <pre><code class="max-height-unset typescript">describe('BannerComponent (inline template)', () => {
  let comp:    BannerComponent;
  let fixture: ComponentFixture&lt;BannerComponent&gt;;
  let de:      DebugElement;
  let el:      HTMLElement;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ BannerComponent ], // declare the test component
    });

    fixture = TestBed.createComponent(BannerComponent);

    comp = fixture.componentInstance; // BannerComponent test instance

    // query for the title &lt;h1&gt; by CSS element selector
    de = fixture.debugElement.query(By.css('h1'));
    el = de.nativeElement;
  });
});</code></pre>
            </section>
            <section>
                <h3>Change detection inside tests</h3>
                <p>For a component to adjust its bindings you need to call <code>detectChanges()</code> to notify Angular that <span class="highlight">change detection</span> needs to be run.</p>
                <p>
                    Example from Angular Docs:
                    <pre><code class="typescript">it('should display a different test title', () => {
  comp.title = 'Test Title';
  fixture.detectChanges();
  expect(el.textContent).toContain('Test Title');
});</code></pre>
                </p>
            </section>
            <section>
                <h3>Testing components with dependencies</h3>
                <p><code>TestBed.configureTestingModule({})</code> has like <code>@NgModule({})</code> a property called <span class="highlight">providers</span>.</p>
                <p>For a component to be able to be build you need to <span class="highlight">register all dependencies</span>.</p>
                <pre><code class="typescript">// 'real' dependency
TestBed.configureTestingModule({
  providers: [ HelloService ] 
  ...
});</code></pre>
                <pre><code class="typescript">// 'fake' dependency
TestBed.configureTestingModule({
  providers: [ { provide: HelloService, useValue: helloServiceFake } ] 
  ...
});</code></pre>
            </section>
            <section>
                <h3>Real vs Fake</h3>
                <p>Both are possible. A real dependency can even be stubbed after creation.</p>
                <p>
                    Note: To stub the real dependency you need to retrieve the runtime instance via
                    <code>ComponentFixture.debugElement.injector.get(Speaker)</code>
                    or <code>TestBed.get(Speaker)</code>.
                    <span class="highlight">Using the components fixture should be preferred</span> since it is less error prone.
                </p>
            </section>
            <section>
                <h3>Testing asynchronous functionality</h3>
                <pre><code class="typescript">it('..', async(() => {
  let sut = new TestService();

  sut.doSomething().then(result => {
    expect(result).toBe('hello');
  });
});</code></pre>
                <p>async makes the test wait until all asynchronous operations are completed.</p>
                <pre><code class="typescript">it('..', fakeAsync((): void => {
  let flag = false;
  setTimeout(() => { flag = true; }, 0);
  expect(flag).toBeFalsy();
  tick();
  expect(flag).toBeTruthy();
}));</code></pre>
                <p><code>tick()</code> lets a completed task run before next code is executed - e.g. XHR fake request.</p>
            </section>
            <section>
                <h3>Emitting events</h3>
                <p><code>DebugElement.triggerEventHandler('click', null)</code> emits a click event.</p>
                <p>TestBed can be configured <pre><code>TestBed.configureTestingModule({
  ...
  schemas: [ NO_ERRORS_SCHEMA ]
})</code></pre> which allows for <span class="highlight">easy EventEmitter (@Output) tests</span>.</p>
                <pre><code class="html">&lt;my-component (somethingChanged)="method($event)"&gt;&lt;/my-component&gt;</code></pre>
                <pre><code class="javascript">debugElement.triggerEventHandler('somethingChanged', whatHasChanged)</code></pre>
            </section>
        </section>
    </div>
</div>

<script src="../reveal.js-3.3.0/lib/js/head.min.js"></script>
<script src="../reveal.js-3.3.0/js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            { src: '../reveal.js-3.3.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: '../reveal.js-3.3.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: '../reveal.js-3.3.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: '../reveal.js-3.3.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: '../reveal.js-3.3.0/plugin/zoom-js/zoom.js', async: true },
            { src: '../reveal.js-3.3.0/plugin/notes/notes.js', async: true }
        ]
    });
</script>
</body>
</html>
